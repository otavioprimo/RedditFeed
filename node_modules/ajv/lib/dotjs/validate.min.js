"use strict";module.exports=function(e,t){function Y(e){for(var t=0;t<e.rules.length;t++)if(Z(e.rules[t]))return!0}function Z(t){return void 0!==e.schema[t.keyword]||"properties"==t.keyword&&(e.schema.additionalProperties===!1||"object"==typeof e.schema.additionalProperties||e.schema.patternProperties&&Object.keys(e.schema.patternProperties).length||e.opts.v5&&e.schema.patternGroups&&Object.keys(e.schema.patternGroups).length)}var r="",n=e.schema.$async===!0;if(e.isTop){var i=e.isTop,o=e.level=0,s=e.dataLevel=0,a="data";if(e.rootId=e.resolve.fullPath(e.root.schema.id),e.baseId=e.baseId||e.rootId,n){e.async=!0;var u="es7"==e.opts.async;e.yieldAwait=u?"await":"yield"}delete e.isTop,e.dataPathArr=[void 0],r+=" var validate = ",n?u?r+=" (async function ":("co*"==e.opts.async&&(r+="co.wrap"),r+="(function* "):r+=" (function ",r+=" (data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; var vErrors = null; ",r+=" var errors = 0;     ",r+=" if (rootData === undefined) rootData = data;"}else{var o=e.level,s=e.dataLevel,a="data"+(s||"");if(e.schema.id&&(e.baseId=e.resolve.url(e.baseId,e.schema.id)),n&&!e.async)throw new Error("async schema in sync schema");r+=" var errs_"+o+" = errors;"}var h,l="valid"+o,c=!e.opts.allErrors,p="",f="",d=e.schema.type,v=Array.isArray(d);if(d&&e.opts.coerceTypes){var m=e.util.coerceToTypes(e.opts.coerceTypes,d);if(m){var g=e.schemaPath+".type",y=e.errSchemaPath+"/type",_=v?"checkDataTypes":"checkDataType";r+=" if ("+e.util[_](d,a,!0)+") {  ";var b="dataType"+o,w="coerced"+o;r+=" var "+b+" = typeof "+a+"; ","array"==e.opts.coerceTypes&&(r+=" if ("+b+" == 'object' && Array.isArray("+a+")) "+b+" = 'array'; "),r+=" var "+w+" = undefined; ";var x="",E=m;if(E)for(var C,S=-1,A=E.length-1;A>S;)C=E[S+=1],S&&(r+=" if ("+w+" === undefined) { ",x+="}"),"array"==e.opts.coerceTypes&&"array"!=C&&(r+=" if ("+b+" == 'array' && "+a+".length == 1) { "+w+" = "+a+" = "+a+"[0]; "+b+" = typeof "+a+";  } "),"string"==C?r+=" if ("+b+" == 'number' || "+b+" == 'boolean') "+w+" = '' + "+a+"; else if ("+a+" === null) "+w+" = ''; ":"number"==C||"integer"==C?(r+=" if ("+b+" == 'boolean' || "+a+" === null || ("+b+" == 'string' && "+a+" && "+a+" == +"+a+" ","integer"==C&&(r+=" && !("+a+" % 1)"),r+=")) "+w+" = +"+a+"; "):"boolean"==C?r+=" if ("+a+" === 'false' || "+a+" === 0 || "+a+" === null) "+w+" = false; else if ("+a+" === 'true' || "+a+" === 1) "+w+" = true; ":"null"==C?r+=" if ("+a+" === '' || "+a+" === 0 || "+a+" === false) "+w+" = null; ":"array"==e.opts.coerceTypes&&"array"==C&&(r+=" if ("+b+" == 'string' || "+b+" == 'number' || "+b+" == 'boolean' || "+a+" == null) "+w+" = ["+a+"]; ");r+=" "+x+" if ("+w+" === undefined) {   ";var k=k||[];k.push(r),r="",e.createErrors!==!1?(r+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(y)+" , params: { type: '",r+=v?""+d.join(","):""+d,r+="' } ",e.opts.messages!==!1&&(r+=" , message: 'should be ",r+=v?""+d.join(","):""+d,r+="' "),e.opts.verbose&&(r+=" , schema: validate.schema"+g+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+a+" "),r+=" } "):r+=" {} ";var T=r;if(r=k.pop(),r+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+T+"]); ":" validate.errors = ["+T+"]; return false; ":" var err = "+T+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" } else { ",s){var P="data"+(s-1||""),O=e.dataPathArr[s];r+=" "+a+" = "+P+"["+O+"] = "+w+"; "}else r+=" data = "+w+"; if (parentData !== undefined) parentData[parentDataProperty] = "+w+"; ";r+=" } } "}}var N;if(e.schema.$ref&&(N=e.util.schemaHasRulesExcept(e.schema,e.RULES.all,"$ref"))){if("fail"==e.opts.extendRefs)throw new Error('$ref: validation keywords used in schema at path "'+e.errSchemaPath+'"');"ignore"==e.opts.extendRefs?(N=!1,console.log('$ref: keywords ignored in schema at path "'+e.errSchemaPath+'"')):e.opts.extendRefs!==!0&&console.log('$ref: all keywords used in schema at path "'+e.errSchemaPath+'". It will change in the next major version, see issue #260. Use option { extendRefs: true } to keep current behaviour')}if(e.schema.$ref&&!N)r+=" "+e.RULES.all.$ref.code(e,"$ref")+" ",c&&(r+=" } if (errors === ",r+=i?"0":"errs_"+o,r+=") { ",f+="}");else{var M=e.RULES;if(M)for(var I,D=-1,R=M.length-1;R>D;)if(I=M[D+=1],Y(I)){if(I.type&&(r+=" if ("+e.util.checkDataType(I.type,a)+") { "),e.opts.useDefaults&&!e.compositeRule)if("object"==I.type&&e.schema.properties){var L=e.schema.properties,j=Object.keys(L),F=j;if(F)for(var V,B=-1,q=F.length-1;q>B;){V=F[B+=1];var U=L[V];if(void 0!==U["default"]){var H=a+e.util.getProperty(V);r+="  if ("+H+" === undefined) "+H+" = ",r+="shared"==e.opts.useDefaults?" "+e.useDefault(U["default"])+" ":" "+JSON.stringify(U["default"])+" ",r+="; "}}}else if("array"==I.type&&Array.isArray(e.schema.items)){var W=e.schema.items;if(W)for(var U,S=-1,z=W.length-1;z>S;)if(U=W[S+=1],void 0!==U["default"]){var H=a+"["+S+"]";r+="  if ("+H+" === undefined) "+H+" = ",r+="shared"==e.opts.useDefaults?" "+e.useDefault(U["default"])+" ":" "+JSON.stringify(U["default"])+" ",r+="; "}}var G=I.rules;if(G)for(var K,Q=-1,J=G.length-1;J>Q;)K=G[Q+=1],Z(K)&&(r+=" "+K.code(e,K.keyword)+" ",c&&(p+="}"));if(c&&(r+=" "+p+" ",p=""),I.type&&(r+=" } ",d&&d===I.type)){var X=!0;r+=" else { ";var g=e.schemaPath+".type",y=e.errSchemaPath+"/type",k=k||[];k.push(r),r="",e.createErrors!==!1?(r+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(y)+" , params: { type: '",r+=v?""+d.join(","):""+d,r+="' } ",e.opts.messages!==!1&&(r+=" , message: 'should be ",r+=v?""+d.join(","):""+d,r+="' "),e.opts.verbose&&(r+=" , schema: validate.schema"+g+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+a+" "),r+=" } "):r+=" {} ";var T=r;r=k.pop(),r+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+T+"]); ":" validate.errors = ["+T+"]; return false; ":" var err = "+T+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" } "}c&&(r+=" if (errors === ",r+=i?"0":"errs_"+o,r+=") { ",f+="}")}}if(d&&!X&&(!e.opts.coerceTypes||!m)){var g=e.schemaPath+".type",y=e.errSchemaPath+"/type",_=v?"checkDataTypes":"checkDataType";r+=" if ("+e.util[_](d,a,!0)+") {   ";var k=k||[];k.push(r),r="",e.createErrors!==!1?(r+=" { keyword: '"+(h||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(y)+" , params: { type: '",r+=v?""+d.join(","):""+d,r+="' } ",e.opts.messages!==!1&&(r+=" , message: 'should be ",r+=v?""+d.join(","):""+d,r+="' "),e.opts.verbose&&(r+=" , schema: validate.schema"+g+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+a+" "),r+=" } "):r+=" {} ";var T=r;r=k.pop(),r+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+T+"]); ":" validate.errors = ["+T+"]; return false; ":" var err = "+T+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" }"}return c&&(r+=" "+f+" "),i?(n?(r+=" if (errors === 0) return true;           ",r+=" else throw new ValidationError(vErrors); "):(r+=" validate.errors = vErrors; ",r+=" return errors === 0;       "),r+=" }); return validate;"):r+=" var "+l+" = errors === errs_"+o+";",r=e.util.cleanUpCode(r),i&&c&&(r=e.util.cleanUpVarErrors(r,n)),r};