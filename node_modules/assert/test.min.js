function makeBlock(t){var e=Array.prototype.slice.call(arguments,1);return function(){return t.apply(this,e)}}function tests(t,e){function n(t){throw new t("test")}test("assert.ok",function(){t["throws"](makeBlock(t,!1),t.AssertionError,"ok(false)"),t.doesNotThrow(makeBlock(t,!0),t.AssertionError,"ok(true)"),t.doesNotThrow(makeBlock(t,"test","ok('test')")),t["throws"](makeBlock(t.ok,!1),t.AssertionError,"ok(false)"),t.doesNotThrow(makeBlock(t.ok,!0),t.AssertionError,"ok(true)"),t.doesNotThrow(makeBlock(t.ok,"test"),"ok('test')")}),test("assert.equal",function(){t["throws"](makeBlock(t.equal,!0,!1),t.AssertionError,"equal"),t.doesNotThrow(makeBlock(t.equal,null,null),"equal"),t.doesNotThrow(makeBlock(t.equal,void 0,void 0),"equal"),t.doesNotThrow(makeBlock(t.equal,null,void 0),"equal"),t.doesNotThrow(makeBlock(t.equal,!0,!0),"equal"),t.doesNotThrow(makeBlock(t.equal,2,"2"),"equal"),t.doesNotThrow(makeBlock(t.notEqual,!0,!1),"notEqual"),t["throws"](makeBlock(t.notEqual,!0,!0),t.AssertionError,"notEqual")}),test("assert.strictEqual",function(){t["throws"](makeBlock(t.strictEqual,2,"2"),t.AssertionError,"strictEqual"),t["throws"](makeBlock(t.strictEqual,null,void 0),t.AssertionError,"strictEqual"),t.doesNotThrow(makeBlock(t.notStrictEqual,2,"2"),"notStrictEqual")}),test("assert.deepStrictEqual",function(){t["throws"](makeBlock(t.deepStrictEqual,[2],["2"]),t.AssertionError,"deepStrictEqual"),t["throws"](makeBlock(t.deepStrictEqual,[null],[void 0]),t.AssertionError,"deepStrictEqual"),t.doesNotThrow(makeBlock(t.notDeepStrictEqual,[2],["2"]),"notDeepStrictEqual")}),test("assert.deepEqual - 7.2",function(){t.doesNotThrow(makeBlock(t.deepEqual,new Date(2e3,3,14),new Date(2e3,3,14)),"deepEqual date"),t["throws"](makeBlock(t.deepEqual,new Date,new Date(2e3,3,14)),t.AssertionError,"deepEqual date")}),test("assert.deepEqual - 7.3",function(){t.doesNotThrow(makeBlock(t.deepEqual,/a/,/a/)),t.doesNotThrow(makeBlock(t.deepEqual,/a/g,/a/g)),t.doesNotThrow(makeBlock(t.deepEqual,/a/i,/a/i)),t.doesNotThrow(makeBlock(t.deepEqual,/a/m,/a/m)),t.doesNotThrow(makeBlock(t.deepEqual,/a/gim,/a/gim)),t["throws"](makeBlock(t.deepEqual,/ab/,/a/)),t["throws"](makeBlock(t.deepEqual,/a/g,/a/)),t["throws"](makeBlock(t.deepEqual,/a/i,/a/)),t["throws"](makeBlock(t.deepEqual,/a/m,/a/)),t["throws"](makeBlock(t.deepEqual,/a/gim,/a/im));var e=/a/;e.lastIndex=3,t["throws"](makeBlock(t.deepEqual,e,/a/))}),test("assert.deepEqual - 7.4",function(){t.doesNotThrow(makeBlock(t.deepEqual,4,"4"),"deepEqual == check"),t.doesNotThrow(makeBlock(t.deepEqual,!0,1),"deepEqual == check"),t["throws"](makeBlock(t.deepEqual,4,"5"),t.AssertionError,"deepEqual == check")}),test("assert.deepEqual - 7.5",function(){t.doesNotThrow(makeBlock(t.deepEqual,{a:4},{a:4})),t.doesNotThrow(makeBlock(t.deepEqual,{a:4,b:"2"},{a:4,b:"2"})),t.doesNotThrow(makeBlock(t.deepEqual,[4],["4"])),t["throws"](makeBlock(t.deepEqual,{a:4},{a:4,b:!0}),t.AssertionError),t.doesNotThrow(makeBlock(t.deepEqual,["a"],{0:"a"})),t.doesNotThrow(makeBlock(t.deepEqual,{a:4,b:"1"},{b:"1",a:4}));var e=[1,2,3],n=[1,2,3];e.a="test",e.b=!0,n.b=!0,n.a="test",t["throws"](makeBlock(t.deepEqual,keys(e),keys(n)),t.AssertionError),t.doesNotThrow(makeBlock(t.deepEqual,e,n))}),test("assert.deepEqual - ES6 primitives",function(){t["throws"](makeBlock(t.deepEqual,null,{}),t.AssertionError),t["throws"](makeBlock(t.deepEqual,void 0,{}),t.AssertionError),t["throws"](makeBlock(t.deepEqual,"a",["a"]),t.AssertionError),t["throws"](makeBlock(t.deepEqual,"a",{0:"a"}),t.AssertionError),t["throws"](makeBlock(t.deepEqual,1,{}),t.AssertionError),t["throws"](makeBlock(t.deepEqual,!0,{}),t.AssertionError),"symbol"==typeof Symbol&&t["throws"](makeBlock(t.deepEqual,Symbol(),{}),t.AssertionError)}),test("assert.deepEqual - object wrappers",function(){t.doesNotThrow(makeBlock(t.deepEqual,new String("a"),["a"])),t.doesNotThrow(makeBlock(t.deepEqual,new String("a"),{0:"a"})),t.doesNotThrow(makeBlock(t.deepEqual,new Number(1),{})),t.doesNotThrow(makeBlock(t.deepEqual,new Boolean(!0),{}))}),test("assert.deepEqual - Buffers",function(){t.doesNotThrow(makeBlock(t.deepEqual,new Buffer([1,2,3]),new Buffer([1,2,3]))),"function"==typeof global.Uint8Array&&t["throws"](makeBlock(t.deepEqual,new Buffer([1,2,3]),new Uint8Array([1,2,3]))),"function"==typeof global.Uint16Array&&t.doesNotThrow(makeBlock(t.deepEqual,new Uint16Array([1,2,3]),new Uint16Array([1,2,3])))}),test("assert - Testing the throwing",function(){var e=makeBlock(n,t.AssertionError);e=makeBlock(n,t.AssertionError),t["throws"](makeBlock(n,t.AssertionError),t.AssertionError,"message"),t["throws"](makeBlock(n,t.AssertionError),t.AssertionError),t["throws"](makeBlock(n,t.AssertionError)),t["throws"](makeBlock(n,TypeError));var r=!1;try{t["throws"](makeBlock(n,TypeError),t.AssertionError)}catch(i){r=!0,t.ok(i instanceof TypeError,"type")}t.equal(!0,r,"a.throws with an explicit error is eating extra errors",t.AssertionError),r=!1;try{t.doesNotThrow(makeBlock(n,TypeError),t.AssertionError)}catch(i){r=!0,t.ok(i instanceof TypeError)}t.equal(!0,r,"a.doesNotThrow with an explicit error is eating extra errors");try{t.doesNotThrow(makeBlock(n,TypeError),TypeError)}catch(i){r=!0,t.ok(i instanceof t.AssertionError)}t.equal(!0,r,"a.doesNotThrow is not catching type matching errors")}),test("assert.ifError",function(){t["throws"](function(){t.ifError(new Error("test error"))}),t.doesNotThrow(function(){t.ifError(null)}),t.doesNotThrow(function(){t.ifError()})}),test("assert - make sure that validating using constructor really works",function(){var e=!1;try{t["throws"](function(){throw{}},Array)}catch(n){e=!0}t.ok(e,"wrong constructor validation")}),test("assert -  use a RegExp to validate error message",function(){t["throws"](makeBlock(n,TypeError),/test/)}),test("assert - se a fn to validate error object",function(){t["throws"](makeBlock(n,TypeError),function(t){return t instanceof TypeError&&/test/.test(t)?!0:void 0})}),test("assert - Make sure deepEqual doesn't loop forever on circular refs",function(){var e={};e.b=e;var n={};n.b=n;var r=!1,i=!0;try{i=t.deepEqual(e,n)}catch(o){r=!0}t.ok(r||!i,r?"got error":"are equal")}),test("assert - Ensure reflexivity of deepEqual with `arguments` objects",function(){var e=function(){return arguments}();t["throws"](makeBlock(t.deepEqual,[],e),t.AssertionError),t["throws"](makeBlock(t.deepEqual,e,[]),t.AssertionError)}),test("assert - test assertion message",function(){function e(e,n){try{t.equal(e,"")}catch(r){t.equal(r.toString(),["AssertionError:",n,"==","''"].join(" "))}}e(void 0,"undefined"),e(null,"null"),e(!0,"true"),e(!1,"false"),e(0,"0"),e(100,"100"),e(NaN,"NaN"),e(1/0,"Infinity"),e(-(1/0),"-Infinity"),e("",'""'),e("foo","'foo'"),e([],"[]"),e([1,2,3],"[ 1, 2, 3 ]"),e(new Buffer([1,2,3]),"<Buffer 01 02 03>"),"function"==typeof global.Uint8Array&&0===Object.getOwnPropertyNames(new Uint8Array([])).length&&e(new Uint8Array([1,2,3]),"{ '0': 1, '1': 2, '2': 3 }"),e(/a/,"/a/"),e(function(){},"[Function: f]"),e({},"{}"),e({a:void 0,b:null},"{ a: undefined, b: null }"),e({a:NaN,b:1/0,c:-(1/0)},"{ a: NaN, b: Infinity, c: -Infinity }")}),test("assert - regressions from node.js testcase",function(){var e=!1;try{t["throws"](function(){t.ifError(null)})}catch(n){e=!0,t.equal(n.message,"Missing expected exception..")}t.ok(e);try{t.equal(1,2)}catch(n){t.equal(n.toString().split("\n")[0],"AssertionError: 1 == 2")}try{t.equal(1,2,"oh no")}catch(n){t.equal(n.toString().split("\n")[0],"AssertionError: oh no")}})}var nodeAssert=require("assert"),ourAssert=require("./"),keys=Object.keys;process.env.TEST_NATIVE===!0?tests(nodeAssert,"node assert"):tests(ourAssert,"our assert");