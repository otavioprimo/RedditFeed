"use strict";var ts=require("typescript"),evaluator_1=require("../src/evaluator"),symbols_1=require("../src/symbols"),typescript_mocks_1=require("./typescript.mocks");describe("Evaluator",function(){var t,r,n,i,o,s,e=ts.createDocumentRegistry();beforeEach(function(){t=new typescript_mocks_1.Host(FILES,["expressions.ts","consts.ts","const_expr.ts","forwardRef.ts","classes.ts","newExpression.ts","errors.ts","declared.ts"]),r=ts.createLanguageService(t,e),n=r.getProgram(),i=n.getTypeChecker(),o=new symbols_1.Symbols(null),s=new evaluator_1.Evaluator(o,new Map)}),it("should not have typescript errors in test data",function(){typescript_mocks_1.expectNoDiagnostics(r.getCompilerOptionsDiagnostics());for(var e=0,t=n.getSourceFiles();e<t.length;e++){var i=t[e];typescript_mocks_1.expectNoDiagnostics(r.getSyntacticDiagnostics(i.fileName)),"errors.ts"!=i.fileName&&typescript_mocks_1.expectNoDiagnostics(r.getSemanticDiagnostics(i.fileName))}}),it("should be able to fold literal expressions",function(){var e=n.getSourceFile("consts.ts");expect(s.isFoldable(typescript_mocks_1.findVar(e,"someName").initializer)).toBeTruthy(),expect(s.isFoldable(typescript_mocks_1.findVar(e,"someBool").initializer)).toBeTruthy(),expect(s.isFoldable(typescript_mocks_1.findVar(e,"one").initializer)).toBeTruthy(),expect(s.isFoldable(typescript_mocks_1.findVar(e,"two").initializer)).toBeTruthy()}),it("should be able to fold expressions with foldable references",function(){var e=n.getSourceFile("expressions.ts");o.define("someName","some-name"),o.define("someBool",!0),o.define("one",1),o.define("two",2),expect(s.isFoldable(typescript_mocks_1.findVar(e,"three").initializer)).toBeTruthy(),expect(s.isFoldable(typescript_mocks_1.findVar(e,"four").initializer)).toBeTruthy(),o.define("three",3),o.define("four",4),expect(s.isFoldable(typescript_mocks_1.findVar(e,"obj").initializer)).toBeTruthy(),expect(s.isFoldable(typescript_mocks_1.findVar(e,"arr").initializer)).toBeTruthy()}),it("should be able to evaluate literal expressions",function(){var e=n.getSourceFile("consts.ts");expect(s.evaluateNode(typescript_mocks_1.findVar(e,"someName").initializer)).toBe("some-name"),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"someBool").initializer)).toBe(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"one").initializer)).toBe(1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"two").initializer)).toBe(2)}),it("should be able to evaluate expressions",function(){var e=n.getSourceFile("expressions.ts");o.define("someName","some-name"),o.define("someBool",!0),o.define("one",1),o.define("two",2),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"three").initializer)).toBe(3),o.define("three",3),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"four").initializer)).toBe(4),o.define("four",4),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"obj").initializer)).toEqual({one:1,two:2,three:3,four:4}),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"arr").initializer)).toEqual([1,2,3,4]),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bTrue").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bFalse").initializer)).toEqual(!1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bAnd").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bOr").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"nDiv").initializer)).toEqual(2),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"nMod").initializer)).toEqual(1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bLOr").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bLAnd").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bBOr").initializer)).toEqual(51),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bBAnd").initializer)).toEqual(1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bXor").initializer)).toEqual(48),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bEqual").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bNotEqual").initializer)).toEqual(!1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bIdentical").initializer)).toEqual(!1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bNotIdentical").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bLessThan").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bGreaterThan").initializer)).toEqual(!1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bLessThanEqual").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bGreaterThanEqual").initializer)).toEqual(!1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bShiftLeft").initializer)).toEqual(4),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bShiftRight").initializer)).toEqual(-1),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bShiftRightU").initializer)).toEqual(-1>>>2)}),it("should report recursive references as symbolic",function(){var e=n.getSourceFile("expressions.ts");expect(s.evaluateNode(typescript_mocks_1.findVar(e,"recursiveA").initializer)).toEqual({__symbolic:"reference",name:"recursiveB"}),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"recursiveB").initializer)).toEqual({__symbolic:"reference",name:"recursiveA"})}),it("should correctly handle special cases for CONST_EXPR",function(){var e=n.getSourceFile("const_expr.ts");expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bTrue").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bFalse").initializer)).toEqual(!1)}),it("should resolve a forwardRef",function(){var e=n.getSourceFile("forwardRef.ts");expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bTrue").initializer)).toEqual(!0),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"bFalse").initializer)).toEqual(!1)}),it("should return new expressions",function(){o.define("Value",{__symbolic:"reference",module:"./classes",name:"Value"}),s=new evaluator_1.Evaluator(o,new Map);var e=n.getSourceFile("newExpression.ts");expect(s.evaluateNode(typescript_mocks_1.findVar(e,"someValue").initializer)).toEqual({__symbolic:"new",expression:{__symbolic:"reference",name:"Value",module:"./classes"},arguments:["name",12]}),expect(s.evaluateNode(typescript_mocks_1.findVar(e,"complex").initializer)).toEqual({__symbolic:"new",expression:{__symbolic:"reference",name:"Value",module:"./classes"},arguments:["name",12]})}),it("should support referene to a declared module type",function(){var e=n.getSourceFile("declared.ts"),t=typescript_mocks_1.findVar(e,"a");expect(s.evaluateNode(t.type)).toEqual({__symbolic:"select",expression:{__symbolic:"reference",name:"Foo"},member:"A"})}),it("should return errors for unsupported expressions",function(){var e=n.getSourceFile("errors.ts"),t=typescript_mocks_1.findVar(e,"f");expect(s.evaluateNode(t.initializer)).toEqual({__symbolic:"error",message:"Function call not supported",line:1,character:12});var r=typescript_mocks_1.findVar(e,"e");expect(s.evaluateNode(r.type)).toEqual({__symbolic:"error",message:"Could not resolve type",line:2,character:11,context:{typeName:"NotFound"}});var i=typescript_mocks_1.findVar(e,"s");expect(s.evaluateNode(i.initializer)).toEqual({__symbolic:"error",message:"Name expected",line:3,character:14,context:{received:"1"}});var o=typescript_mocks_1.findVar(e,"t");expect(s.evaluateNode(o.initializer)).toEqual({__symbolic:"error",message:"Expression form not supported",line:4,character:12})}),it("should be able to fold an array spread",function(){var e=n.getSourceFile("expressions.ts");o.define("arr",[1,2,3,4]);var t=typescript_mocks_1.findVar(e,"arrSpread");expect(s.evaluateNode(t.initializer)).toEqual([0,1,2,3,4,5])}),it("should be able to produce a spread expression",function(){var e=n.getSourceFile("expressions.ts"),t=typescript_mocks_1.findVar(e,"arrSpreadRef");expect(s.evaluateNode(t.initializer)).toEqual([0,{__symbolic:"spread",expression:{__symbolic:"reference",name:"arrImport"}},5])})});var FILES={"directives.ts":"\n    export function Pipe(options: { name?: string, pure?: boolean}) {\n      return function(fn: Function) { }\n    }\n    ","classes.ts":"\n    export class Value {\n      constructor(public name: string, public value: any) {}\n    }\n  ","consts.ts":"\n    export var someName = 'some-name';\n    export var someBool = true;\n    export var one = 1;\n    export var two = 2;\n    export var arrImport = [1, 2, 3, 4];\n  ","expressions.ts":'\n    import {arrImport} from \'./consts\';\n\n    export var someName = \'some-name\';\n    export var someBool = true;\n    export var one = 1;\n    export var two = 2;\n\n    export var three = one + two;\n    export var four = two * two;\n    export var obj = { one: one, two: two, three: three, four: four };\n    export var arr = [one, two, three, four];\n    export var bTrue = someBool;\n    export var bFalse = !someBool;\n    export var bAnd = someBool && someBool;\n    export var bOr = someBool || someBool;\n    export var nDiv = four / two;\n    export var nMod = (four + one) % two;\n\n    export var bLOr = false || true;             // true\n    export var bLAnd = true && true;             // true\n    export var bBOr = 0x11 | 0x22;               // 0x33\n    export var bBAnd = 0x11 & 0x03;              // 0x01\n    export var bXor = 0x11 ^ 0x21;               // 0x20\n    export var bEqual = 1 == <any>"1";           // true\n    export var bNotEqual = 1 != <any>"1";        // false\n    export var bIdentical = 1 === <any>"1";      // false\n    export var bNotIdentical = 1 !== <any>"1";   // true\n    export var bLessThan = 1 < 2;                // true\n    export var bGreaterThan = 1 > 2;             // false\n    export var bLessThanEqual = 1 <= 2;          // true\n    export var bGreaterThanEqual = 1 >= 2;       // false\n    export var bShiftLeft = 1 << 2;              // 0x04\n    export var bShiftRight = -1 >> 2;            // -1\n    export var bShiftRightU = -1 >>> 2;          // 0x3fffffff\n\n    export var arrSpread = [0, ...arr, 5];\n\n    export var arrSpreadRef = [0, ...arrImport, 5];\n\n    export var recursiveA = recursiveB;\n    export var recursiveB = recursiveA;\n  ',"A.ts":"\n    import {Pipe} from './directives';\n\n    @Pipe({name: 'A', pure: false})\n    export class A {}","B.ts":"\n    import {Pipe} from './directives';\n    import {someName, someBool} from './consts';\n\n    @Pipe({name: someName, pure: someBool})\n    export class B {}","const_expr.ts":"\n    function CONST_EXPR(value: any) { return value; }\n    export var bTrue = CONST_EXPR(true);\n    export var bFalse = CONST_EXPR(false);\n  ","forwardRef.ts":"\n    function forwardRef(value: any) { return value; }\n    export var bTrue = forwardRef(() => true);\n    export var bFalse = forwardRef(() => false);\n  ","newExpression.ts":'\n    import {Value} from \'./classes\';\n    function CONST_EXPR(value: any) { return value; }\n    function forwardRef(value: any) { return value; }\n    export const someValue = new Value("name", 12);\n    export const complex = CONST_EXPR(new Value("name", forwardRef(() => 12)));\n  ',"errors.ts":"\n    let f = () => 1;\n    let e: NotFound;\n    let s = { 1: 1, 2: 2 };\n    let t = typeof 12;\n  ","declared.ts":"\n    declare namespace Foo {\n      type A = string;\n    }\n\n    let a: Foo.A = 'some value';\n  "};