"use strict";var ts=require("typescript"),schema_1=require("../src/schema"),symbols_1=require("../src/symbols"),typescript_mocks_1=require("./typescript.mocks");describe("Symbols",function(){var e,t="some-value";beforeEach(function(){return e=new symbols_1.Symbols(null)}),it("should be able to add a symbol",function(){return e.define("someSymbol",t)}),beforeEach(function(){return e.define("someSymbol",t)}),it("should be able to `has` a symbol",function(){return expect(e.has("someSymbol")).toBeTruthy()}),it("should be able to `get` a symbol value",function(){return expect(e.resolve("someSymbol")).toBe(t)}),it("should be able to `get` a symbol value",function(){return expect(e.resolve("someSymbol")).toBe(t)}),it("should be able to determine symbol is missing",function(){return expect(e.has("missingSymbol")).toBeFalsy()}),it("should return undefined from `get` for a missing symbol",function(){return expect(e.resolve("missingSymbol")).toBeUndefined()});var r,n,i,o,s;beforeEach(function(){r=new typescript_mocks_1.Host(FILES,["consts.ts","expressions.ts","imports.ts"]),n=ts.createLanguageService(r),i=n.getProgram(),o=i.getSourceFile("expressions.ts"),s=i.getSourceFile("imports.ts")}),it("should not have syntax errors in the test sources",function(){typescript_mocks_1.expectNoDiagnostics(n.getCompilerOptionsDiagnostics());for(var e=0,t=i.getSourceFiles();e<t.length;e++){var r=t[e];typescript_mocks_1.expectNoDiagnostics(n.getSyntacticDiagnostics(r.fileName))}}),it("should be able to find the source files",function(){expect(o).toBeDefined(),expect(s).toBeDefined()}),it("should be able to create symbols for a source file",function(){var e=new symbols_1.Symbols(o);expect(e).toBeDefined()}),it("should be able to find symbols in expression",function(){var e=new symbols_1.Symbols(o);expect(e.has("someName")).toBeTruthy(),expect(e.resolve("someName")).toEqual({__symbolic:"reference",module:"./consts",name:"someName"}),expect(e.has("someBool")).toBeTruthy(),expect(e.resolve("someBool")).toEqual({__symbolic:"reference",module:"./consts",name:"someBool"})}),it("should be able to detect a * import",function(){var e=new symbols_1.Symbols(s);expect(e.resolve("b")).toEqual({__symbolic:"reference",module:"b"})}),it("should be able to detect importing a default export",function(){var e=new symbols_1.Symbols(s);expect(e.resolve("d")).toEqual({__symbolic:"reference",module:"d","default":!0})}),it("should be able to import a renamed symbol",function(){var e=new symbols_1.Symbols(s);expect(e.resolve("g")).toEqual({__symbolic:"reference",name:"f",module:"f"})}),it("should be able to resolve any symbol in core global scope",function(){var t=i.getSourceFiles().find(function(e){return e.fileName.endsWith("lib.d.ts")});expect(t).toBeDefined();var r=function(t){switch(t.kind){case ts.SyntaxKind.VariableStatement:case ts.SyntaxKind.VariableDeclarationList:return ts.forEachChild(t,r);case ts.SyntaxKind.VariableDeclaration:var n=t,i=n.name,o=i.text,s=e.resolve(o);return expect(schema_1.isMetadataGlobalReferenceExpression(s)&&s.name).toEqual(o),"Float64Array"===o}return!1};ts.forEachChild(t,r)})});var FILES={"consts.ts":"\n    export var someName = 'some-name';\n    export var someBool = true;\n    export var one = 1;\n    export var two = 2;\n  ","expressions.ts":"\n    import {someName, someBool, one, two} from './consts';\n  ","imports.ts":"\n    import * as b from 'b';\n    import 'c';\n    import d from 'd';\n    import {f as g} from 'f';\n  "};