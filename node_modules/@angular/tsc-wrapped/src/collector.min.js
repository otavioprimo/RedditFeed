"use strict";function validateMetadata(e,t,r){function i(e){if(e)if(Array.isArray(e))e.forEach(i);else if("object"!=typeof e||e.hasOwnProperty("__symbolic")){if(schema_1.isMetadataError(e))c(e);else if(schema_1.isMetadataGlobalReferenceExpression(e)){if(!n.has(e.name)){var t=r[e.name];t&&i(t)}}else if(schema_1.isFunctionMetadata(e))a(e);else if(schema_1.isMetadataSymbolicExpression(e))switch(e.__symbolic){case"binary":var o=e;i(o.left),i(o.right);break;case"call":case"new":var s=e;i(s.expression),s.arguments&&s.arguments.forEach(i);break;case"index":var u=e;i(u.expression),i(u.index);break;case"pre":var l=e;i(l.operand);break;case"select":var p=e;i(p.expression);break;case"spread":var f=e;i(f.expression);break;case"if":var h=e;i(h.condition),i(h.elseExpression),i(h.thenExpression)}}else Object.getOwnPropertyNames(e).forEach(function(t){return i(e[t])})}function o(e){e.decorators&&e.decorators.forEach(i),schema_1.isMethodMetadata(e)&&e.parameterDecorators&&e.parameterDecorators.forEach(i),schema_1.isConstructorMetadata(e)&&e.parameters&&e.parameters.forEach(i)}function s(e){e.decorators&&e.decorators.forEach(i),e.members&&Object.getOwnPropertyNames(e.members).forEach(function(t){return e.members[t].forEach(o)})}function a(e){if(e.value){var t=n;e.parameters&&(n=new Set(t.values()),e.parameters&&e.parameters.forEach(function(e){return n.add(e)})),i(e.value),n=t}}function u(t){if(t){var r=t.getStart();return!(t.pos!=r&&e.text.substring(t.pos,r).indexOf("@dynamic")>=0)}return!0}function c(r){var n=t.get(r);if(u(n)){var i=void 0!=r.line?void 0!=r.character?":"+(r.line+1)+":"+(r.character+1):":"+(r.line+1):"";throw new Error(""+e.fileName+i+": Metadata collected contains an error that will be reported at runtime: "+expandedMessage(r)+".\n  "+JSON.stringify(r))}}var n=new Set(["Array","Object","Set","Map","string","number","any"]);Object.getOwnPropertyNames(r).forEach(function(n){var i=r[n];try{schema_1.isClassMetadata(i)&&s(i)}catch(o){var a=t.get(i);if(u(a)){if(a){var c=e.getLineAndCharacterOfPosition(a.getStart()),l=c.line,p=c.character;throw new Error(e.fileName+":"+(l+1)+":"+(p+1)+": Error encountered in metadata generated for exported symbol '"+n+"': \n "+o.message)}throw new Error("Error encountered in metadata generated for exported symbol "+n+": \n "+o.message)}}})}function namesOf(e){function r(e){if(e.kind==ts.SyntaxKind.Identifier){var n=e;t.push(n.text)}else for(var i=e,o=0,s=i.elements;o<s.length;o++){var a=s[o];r(a.name)}}for(var t=[],n=0,i=e;n<i.length;n++){var o=i[n];r(o.name)}return t}function expandedMessage(e){switch(e.message){case"Reference to non-exported class":if(e.context&&e.context.className)return"Reference to a non-exported class "+e.context.className+". Consider exporting the class";break;case"Variable not initialized":return"Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler";case"Destructuring not supported":return"Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring";case"Could not resolve type":if(e.context&&e.context.typeName)return"Could not resolve type "+e.context.typeName;break;case"Function call not supported":var t=e.context&&e.context.name?"Calling function '"+e.context.name+"', f":"F";return t+"unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function";case"Reference to a local symbol":if(e.context&&e.context.name)return"Reference to a local (non-exported) symbol '"+e.context.name+"'. Consider exporting the symbol"}return e.message}var ts=require("typescript"),evaluator_1=require("./evaluator"),schema_1=require("./schema"),symbols_1=require("./symbols"),MetadataCollector=function(){function e(){}return e.prototype.getMetadata=function(e,t){function a(e){return i.evaluateNode(e.expression)}function u(e,t){return n.set(e,t),e}function c(t,r,n){return evaluator_1.errorSymbol(t,r,n,e)}function l(e){if(e.name.kind==ts.SyntaxKind.Identifier){var t=e.name,r=t.text,n=e.body;if(n&&1==n.statements.length){var o=n.statements[0];if(o.kind===ts.SyntaxKind.ReturnStatement){var s=o;if(s.expression){var a={__symbolic:"function",parameters:namesOf(e.parameters),value:i.evaluateNode(s.expression)};if(e.parameters.some(function(e){return null!=e.initializer})){a.defaults=e.parameters.map(function(e){return e.initializer&&i.evaluateNode(e.initializer)})}return u({func:a,name:r},e)}}}}}function p(e){function r(e){return e&&e.length?e.map(function(e){return a(e)}):void 0}function n(e){var t=i.evaluateNode(e);return schema_1.isMetadataError(t)||schema_1.isMetadataSymbolicReferenceExpression(t)||schema_1.isMetadataSymbolicSelectExpression(t)?t:c("Symbol reference expected",e)}function s(e,t){o||(o={});var r=o.hasOwnProperty(e)?o[e]:[];r.push(t),o[e]=r}function f(e,t){p||(p={}),p[e]=t}var t={__symbolic:"class"};e.decorators&&(t.decorators=r(e.decorators));for(var o=null,p=null,h=0,d=e.members;h<d.length;h++){var v=d[h],y=!1;switch(v.kind){case ts.SyntaxKind.Constructor:case ts.SyntaxKind.MethodDeclaration:y=v.kind===ts.SyntaxKind.Constructor;var m=v;if(m.flags&ts.NodeFlags.Static){var g=l(m);g&&f(g.name,g.func);continue}for(var _=r(m.decorators),w=m.parameters,b=[],E=[],C=!1,S=!1,x=0,T=w;x<T.length;x++){var A=T[x],P=r(A.decorators);b.push(P),C=C||!!P,y&&(A.type?E.push(n(A.type)):E.push(null),S=!0)}var O={__symbolic:y?"constructor":"method"},M=y?"__ctor__":i.nameOf(v.name);_&&(O.decorators=_),C&&(O.parameterDecorators=b),S&&(O.parameters=E),schema_1.isMetadataError(M)||s(M,O);break;case ts.SyntaxKind.PropertyDeclaration:case ts.SyntaxKind.GetAccessor:case ts.SyntaxKind.SetAccessor:var k=v;if(k.flags&ts.NodeFlags.Static){var N=i.nameOf(k.name);if(!schema_1.isMetadataError(N))if(k.initializer){var I=i.evaluateNode(k.initializer);f(N,I)}else f(N,c("Variable not initialized",k.name))}var D=r(k.decorators);if(D){var R=i.nameOf(k.name);schema_1.isMetadataError(R)||s(R,{__symbolic:"property",decorators:D})}}}return o&&(t.members=o),p&&(t.statics=p),t.decorators||o||p?u(t,e):void 0}void 0===t&&(t=!1);var o,s,r=new symbols_1.Symbols(e),n=new Map,i=new evaluator_1.Evaluator(r,n);if(ts.forEachChild(e,function(e){switch(e.kind){case ts.SyntaxKind.ClassDeclaration:var t=e,n=t.name.text;e.flags&ts.NodeFlags.Export?r.define(n,{__symbolic:"reference",name:n}):r.define(n,c("Reference to non-exported class",e,{className:n}));break;case ts.SyntaxKind.FunctionDeclaration:if(!(e.flags&ts.NodeFlags.Export)){var i=e,o=i.name;r.define(o.text,c("Reference to a non-exported function",o,{name:o.text}))}}}),ts.forEachChild(e,function(e){switch(e.kind){case ts.SyntaxKind.ExportDeclaration:var t=e,n=t.moduleSpecifier;if(n&&n.kind==ts.SyntaxKind.StringLiteral){var a=n.text,f={from:a};t.exportClause&&(f["export"]=t.exportClause.elements.map(function(e){return e.propertyName?{name:e.propertyName.text,as:e.name.text}:e.name.text})),s||(s=[]),s.push(f)}break;case ts.SyntaxKind.ClassDeclaration:var h=e,d=h.name.text;e.flags&ts.NodeFlags.Export&&h.decorators&&(o||(o={}),o[d]=p(h));break;case ts.SyntaxKind.FunctionDeclaration:var v=e;if(e.flags&ts.NodeFlags.Export){var y=l(v);y&&(o||(o={}),o[y.name]=u(y.func,e))}break;case ts.SyntaxKind.EnumDeclaration:if(e.flags&ts.NodeFlags.Export){for(var m=e,g={},_=m.name.text,w=0,b=0,E=0,C=m.members;E<C.length;E++){var S=C[E],x=void 0;x=S.initializer?i.evaluateNode(S.initializer):w;var T=void 0;if(S.name.kind==ts.SyntaxKind.Identifier){var A=S.name;T=A.text,g[T]=x,b++}w="number"==typeof x?x+1:T?{__symbolic:"binary",operator:"+",left:{__symbolic:"select",expression:u({__symbolic:"reference",name:_},e),name:T}}:u(c("Unsuppported enum member name",S.name),e)}b&&(o||(o={}),o[_]=u(g,e))}break;case ts.SyntaxKind.VariableStatement:for(var P=e,O=function(t){if(t.name.kind==ts.SyntaxKind.Identifier){var n=t.name,s=void 0;s=t.initializer?i.evaluateNode(t.initializer):u(c("Variable not initialized",n),n);var a=!1;(P.flags&ts.NodeFlags.Export||t.flags&ts.NodeFlags.Export)&&(o||(o={}),o[n.text]=u(s,e),a=!0),evaluator_1.isPrimitive(s)?r.define(n.text,s):a||(s&&!schema_1.isMetadataError(s)?r.define(n.text,u(s,e)):r.define(n.text,u(c("Reference to a local symbol",n,{name:n.text}),e)))}else{var l=function(t){switch(t.kind){case ts.SyntaxKind.Identifier:var n=t,i=c("Destructuring not supported",t);r.define(n.text,i),e.flags&ts.NodeFlags.Export&&(o||(o={}),o[n.text]=i);break;case ts.SyntaxKind.BindingElement:var s=t;l(s.name);break;case ts.SyntaxKind.ObjectBindingPattern:case ts.SyntaxKind.ArrayBindingPattern:var a=t;a.elements.forEach(l)}};l(t.name)}},M=0,k=P.declarationList.declarations;M<k.length;M++){var N=k[M];O(N)}}}),o||s){o?t&&validateMetadata(e,n,o):o={};var f={__symbolic:"module",version:schema_1.VERSION,metadata:o};return s&&(f.exports=s),f}},e}();exports.MetadataCollector=MetadataCollector;