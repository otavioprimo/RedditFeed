"use strict";var interfaces_1=require("../util/interfaces"),file_cache_1=require("../util/file-cache"),watch_1=require("../watch"),watch_2=require("../watch"),path=require("path");describe("watch",function(){describe("runBuildUpdate",function(){it("should get the html file if thats the only one",function(){var t=[{event:"change",filePath:"file1.html",ext:".html"}],r=watch_1.runBuildUpdate(e,t);expect(r.filePath).toEqual("file1.html")}),it("should get the scss file for the filePath over html",function(){var t=[{event:"change",filePath:"file1.html",ext:".html"},{event:"change",filePath:"file1.scss",ext:".scss"}],r=watch_1.runBuildUpdate(e,t);expect(r.filePath).toEqual("file1.scss")}),it("should get the ts file for the filePath over the others",function(){var t=[{event:"change",filePath:"file1.html",ext:".html"},{event:"change",filePath:"file1.scss",ext:".scss"},{event:"change",filePath:"file1.ts",ext:".ts"}],r=watch_1.runBuildUpdate(e,t);expect(r.filePath).toEqual("file1.ts")}),it("should require transpile full build for html file add",function(){var t=[{event:"add",filePath:"file1.html",ext:".html"}];watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should require transpile full build for html file change and not already successful bundle",function(){var t=[{event:"change",filePath:"file1.html",ext:".html"}];watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should require template update for html file change and already successful bundle",function(){var t=[{event:"change",filePath:"file1.html",ext:".html"}];e.bundleState=interfaces_1.BuildState.SuccessfulBuild,watch_1.runBuildUpdate(e,t),expect(e.templateState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require sass update for ts file unlink",function(){var t=[{event:"unlink",filePath:"file1.ts",ext:".ts"}];watch_1.runBuildUpdate(e,t),expect(e.sassState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require sass update for ts file add",function(){var t=[{event:"add",filePath:"file1.ts",ext:".ts"}];watch_1.runBuildUpdate(e,t),expect(e.sassState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require sass update for scss file add",function(){var t=[{event:"add",filePath:"file1.scss",ext:".scss"}];watch_1.runBuildUpdate(e,t),expect(e.sassState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require sass update for scss file change",function(){var t=[{event:"change",filePath:"file1.scss",ext:".scss"}];watch_1.runBuildUpdate(e,t),expect(e.sassState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require transpile full build for single ts add, but only bundle update when already successful bundle",function(){var t=[{event:"add",filePath:"file1.ts",ext:".ts"}];e.bundleState=interfaces_1.BuildState.SuccessfulBuild,watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require transpile full build for single ts add",function(){var t=[{event:"add",filePath:"file1.ts",ext:".ts"}];watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should require transpile full build for single ts change and not in file cache",function(){var t=[{event:"change",filePath:"file1.ts",ext:".ts"}];watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should require transpile update only and full bundle build for single ts change and already in file cache and hasnt already had successful bundle",function(){var t=[{event:"change",filePath:"file1.ts",ext:".ts"}];e.bundleState=interfaces_1.BuildState.SuccessfulBuild;var r=path.resolve("file1.ts");e.fileCache.set(r,{path:"file1.ts",content:"content"}),watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresUpdate),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresUpdate)}),it("should require transpile update only and bundle update for single ts change and already in file cache and bundle already successful",function(){var t=[{event:"change",filePath:"file1.ts",ext:".ts"}],r=path.resolve("file1.ts");e.fileCache.set(r,{path:"file1.ts",content:"content"}),watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresUpdate),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should require transpile full build for multiple ts changes",function(){var t=[{event:"change",filePath:"file1.ts",ext:".ts"},{event:"change",filePath:"file2.ts",ext:".ts"}];watch_1.runBuildUpdate(e,t),expect(e.transpileState).toEqual(interfaces_1.BuildState.RequiresBuild),expect(e.bundleState).toEqual(interfaces_1.BuildState.RequiresBuild)}),it("should not update bundle state if no transpile changes",function(){var t=[{event:"change",filePath:"file1.scss",ext:".scss"}];watch_1.runBuildUpdate(e,t),expect(e.bundleState).toEqual(void 0)}),it("should set add event when add and changed files",function(){var t=[{event:"change",filePath:"file1.ts",ext:".ts"},{event:"add",filePath:"file2.ts",ext:".ts"}],r=watch_1.runBuildUpdate(e,t);expect(r.event).toEqual("add")}),it("should set unlink event when only unlinked files",function(){var t=[{event:"unlink",filePath:"file.ts",ext:".ts"}],r=watch_1.runBuildUpdate(e,t);expect(r.event).toEqual("unlink")}),it("should set change event when only changed files",function(){var t=[{event:"change",filePath:"file.ts",ext:".ts"}],r=watch_1.runBuildUpdate(e,t);expect(r.event).toEqual("change")}),it("should do nothing if there are no changed files",function(){expect(watch_1.runBuildUpdate(e,[])).toEqual(null),expect(watch_1.runBuildUpdate(e,null)).toEqual(null)});var e;beforeEach(function(){e={fileCache:new file_cache_1.FileCache}})}),describe("prepareWatcher",function(){it("should do nothing when options.ignored is a function",function(){var e=function(){},t={options:{ignored:e}},r={srcDir:"/some/src/"};watch_2.prepareWatcher(r,t),expect(t.options.ignored).toBe(e)}),it("should set replacePathVars when options.ignored is a string",function(){var e={options:{ignored:"{{SRC}}/**/*.spec.ts"}},t={srcDir:"/some/src/"};watch_2.prepareWatcher(t,e),expect(e.options.ignored).toEqual("/some/src/**/*.spec.ts")}),it("should set replacePathVars when paths is an array",function(){var e={paths:["{{SRC}}/some/path1","{{SRC}}/some/path2"]},t={srcDir:"/some/src/"};watch_2.prepareWatcher(t,e),expect(e.paths.length).toEqual(2),expect(e.paths[0]).toEqual("/some/src/some/path1"),expect(e.paths[1]).toEqual("/some/src/some/path2")}),it("should set replacePathVars when paths is a string",function(){var e={paths:"{{SRC}}/some/path"},t={srcDir:"/some/src/"};watch_2.prepareWatcher(t,e),expect(e.paths).toEqual("/some/src/some/path")}),it("should not set options.ignoreInitial if it was provided",function(){var e={options:{ignoreInitial:!1}},t={};watch_2.prepareWatcher(t,e),expect(e.options.ignoreInitial).toEqual(!1)}),it("should set options.ignoreInitial to true if it wasnt provided",function(){var e={options:{}},t={};watch_2.prepareWatcher(t,e),expect(e.options.ignoreInitial).toEqual(!0)}),it("should not set options.cwd from context.rootDir if it was provided",function(){var e={options:{cwd:"/my/cwd/"}},t={rootDir:"/my/root/dir/"};watch_2.prepareWatcher(t,e),expect(e.options.cwd).toEqual("/my/cwd/")}),it("should set options.cwd from context.rootDir if it wasnt provided",function(){var e={},t={rootDir:"/my/root/dir/"};watch_2.prepareWatcher(t,e),expect(e.options.cwd).toEqual(t.rootDir)}),it("should create watcher options when not provided",function(){var e={},t={};watch_2.prepareWatcher(t,e),expect(e.options).toBeDefined()})})});